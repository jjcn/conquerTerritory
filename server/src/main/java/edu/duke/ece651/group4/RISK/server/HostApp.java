
        /*
         * This Java source file was generated by the Gradle 'init' task.
         */
        package edu.duke.ece651.group4.RISK.server;

import edu.duke.ece651.group4.RISK.shared.Client;
import edu.duke.ece651.group4.RISK.shared.Territory;
import edu.duke.ece651.group4.RISK.shared.World;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CyclicBarrier;

public class HostApp implements Runnable {
    ServerSocket hostSocket;
    World theWorld;
    HostState hostState;
    int numOfPlayers;
    ArrayList<String> playerNames;
    CyclicBarrier barrier;
    private int numTerritoryPerPlayer;
    HashMap<Integer, List<Territory>> groups;

    /*
     * This constructs the hostApp
     * */
    HostApp(ServerSocket hostSocket,int num){
        this.hostSocket = hostSocket;
        this.hostState = new HostState("WaitForUpdateWorld");
        this.barrier = null;
        this.numOfPlayers = 0;
        this.theWorld = null;
        this.playerNames = new ArrayList<>();
        this.numTerritoryPerPlayer=num;
        this.groups= new HashMap<>();

    }

    /*
     *  This function is to read init info about this whole game
     *  This need to set up the world, the number of players.
     *  First, we read all info we need to set up a world.
     *  We need to set up the number of players.
     *  We need to assign PlayerID to each block of territories
     *  We need to create ListArray<String> Player Names
     *  We need to make sure all variables related world and players are initialized
     * */

    private void setUpWorld() {
        String instruct1 = "Please enter the Player Number";
        BufferedReader inRead = new BufferedReader(new InputStreamReader(System.in));


        int playerNum = 0;
        while (playerNum == 0) {
            try {
                System.out.println(instruct1);
                String playerNumRead = inRead.readLine();
                if (!isNumeric(playerNumRead)) {
                    throw new IllegalArgumentException();
                }
                playerNum = Integer.parseInt(playerNumRead);

            } catch (Exception e) {
                System.out.println("Please enter correct number!");
            }
        }
        this.numOfPlayers=playerNum;
        this.theWorld=new World(playerNum*this.numTerritoryPerPlayer);
        this.groups=(HashMap<Integer, List<Territory>>) this.theWorld.divideTerritories(playerNum);
    }

    public boolean isNumeric(String strNum) {
        if (strNum == null) {
            return false;
        }
        try {
            double d = Double.parseDouble(strNum);
        } catch (NumberFormatException nfe) {
            return false;
        }
        return true;
    }


    /*
     * This setup connection between server and clients
     * Will assign a PlayerID to each thread we are creating
     *
     *  */

    private void setUpClients() {
        int PlayerID = 0;
        try {
            while(PlayerID < numOfPlayers) {
                Socket s = hostSocket.accept();
                Client theClient = new Client(s);
                PlayerState playerState = new PlayerState("Ready");
                playerNames.add( "Player" + PlayerID);
                hostState.addOnePlayerState(playerState);
                ClientThread theThread = new ClientThread(theWorld, playerNames.get(PlayerID), PlayerID, barrier, playerState,
                        theClient, hostState,this.groups.get(PlayerID));
                theThread.start();
                PlayerID += 1;
            }
        }catch(IOException e){
            System.out.println("Socket Problem");
        }
    }

    /*
     * This will finish all attacks on world and get a final new world.
     * And change the hostSate to "finishUpdateMap"
     * If some players are not done with one turn, skip
     * */

    private void finishBattlesOneTurn() {
        if(!hostState.isFinishUpdate()) {
            theWorld.doAllBattles();
            hostState.changeStateTo("finishUpdateWorld");
            System.out.println("The host finish updating the world after do all battles.");
        }
    }


    /*
     * This is the the main function of the game process
     * */
    public void run() {
        setUpWorld();
        barrier = new CyclicBarrier(numOfPlayers);
        setUpClients();

        while(true) {
            if(hostState.isAllPlayersDoneOneTurn()) {
                finishBattlesOneTurn();
            }
            if(hostState.isALlThreadsQuit()) {
                System.out.println("The host quits after all threads quit.");
                break;  // we should decide to quit the game after all thread  quit.
            }
        }
    }

    public static void main(String[] args) throws IOException {
        ServerSocket hostSocket = new ServerSocket(9999);
        HostApp hostApp = new HostApp(hostSocket,3);
        hostApp.run();
    }
}


